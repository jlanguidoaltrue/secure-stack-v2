"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose-field-encryption";
exports.ids = ["vendor-chunks/mongoose-field-encryption"];
exports.modules = {

/***/ "(ssr)/../backend/node_modules/mongoose-field-encryption/lib/mongoose-field-encryption.js":
/*!******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose-field-encryption/lib/mongoose-field-encryption.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst algorithm = \"aes-256-cbc\";\nconst deprecatedAlgorithm = \"aes-256-ctr\";\nconst encryptedFieldNamePrefix = \"__enc_\";\nconst encryptedFieldDataSuffix = \"_d\";\n\nconst encryptAes256Ctr = function(text, secret) {\n  const cipher = crypto.createCipher(deprecatedAlgorithm, secret);\n  let crypted = cipher.update(text, \"utf8\", \"hex\");\n  crypted += cipher.final(\"hex\");\n  return crypted;\n};\n\nconst decryptAes256Ctr = function(encryptedHex, secret) {\n  const decipher = crypto.createDecipher(deprecatedAlgorithm, secret);\n  let dec = decipher.update(encryptedHex, \"hex\", \"utf8\");\n  dec += decipher.final(\"utf8\");\n  return dec;\n};\n\nconst encrypt = function(clearText, secret, saltGenerator) {\n  const iv = saltGeneratorWrapper(saltGenerator(secret));\n  const cipher = crypto.createCipheriv(algorithm, secret, iv);\n  const encrypted = cipher.update(clearText);\n  const finalBuffer = Buffer.concat([encrypted, cipher.final()]);\n  const encryptedHex = iv.toString(\"hex\") + \":\" + finalBuffer.toString(\"hex\");\n  return encryptedHex;\n};\n\nconst saltGeneratorWrapper = iv => {\n  if (iv instanceof Buffer) {\n    if (iv.length !== 16) {\n      throw new Error(\"Invalid salt provided, please ensure that the salt is a Buffer of length 16\");\n    }\n    return iv;\n  }\n\n  if (typeof iv === \"string\" || iv instanceof String) {\n    if (iv.length !== 16) {\n      throw new Error(\"Invalid salt, please ensure that the salt is a string of length 16\");\n    }\n    return Buffer.from(iv);\n  }\n\n  throw new Error(\"Invalid salt, please ensure that the salt is either a string or a Buffer of length 16\");\n};\n\nconst defaultSaltGenerator = secret => crypto.randomBytes(16);\n\n/**\n * Decryption has a default fallback for the deprecated algorithm\n *\n * @param {*} encryptedHex\n * @param {*} secret\n */\nconst decrypt = function(encryptedHex, secret) {\n  const encryptedArray = encryptedHex.split(\":\");\n\n  // maintain backwards compatibility\n  if (encryptedArray.length === 1) {\n    return decryptAes256Ctr(encryptedArray[0], secret);\n  }\n\n  const iv = new Buffer.from(encryptedArray[0], \"hex\");\n  const encrypted = new Buffer.from(encryptedArray[1], \"hex\");\n  const decipher = crypto.createDecipheriv(algorithm, secret, iv);\n  const decrypted = decipher.update(encrypted);\n  const clearText = Buffer.concat([decrypted, decipher.final()]).toString();\n  return clearText;\n};\n\nconst fieldEncryption = function(schema, options) {\n  if (!options || !options.secret) {\n    throw new Error(\"missing required secret\");\n  }\n\n  const useAes256Ctr = options.useAes256Ctr || false;\n  const fieldsToEncrypt = options.fields || [];\n\n  const hash = crypto.createHash(\"sha256\");\n  hash.update(options.secret);\n\n  const secret = useAes256Ctr ? options.secret : hash.digest(\"hex\").substring(0, 32);\n  const encryptionStrategy = useAes256Ctr ? encryptAes256Ctr : encrypt;\n  const saltGenerator = options.saltGenerator ? options.saltGenerator : defaultSaltGenerator;\n\n  // add marker fields to schema\n  for (const field of fieldsToEncrypt) {\n    const encryptedFieldName = encryptedFieldNamePrefix + field;\n    const encryptedFieldData = encryptedFieldName + encryptedFieldDataSuffix;\n    const schemaField = {};\n\n    schemaField[encryptedFieldName] = { type: Boolean };\n    schemaField[encryptedFieldData] = { type: String };\n    schema.add(schemaField);\n  }\n\n  //\n  // local methods\n  //\n\n  // for mongoose 4/5 compatibility\n  const defaultNext = function defaultNext(err) {\n    if (err) {\n      throw err;\n    }\n  };\n\n  function getCompatitibleNextFunc(next) {\n    if (typeof next !== \"function\") {\n      return defaultNext;\n    }\n    return next;\n  }\n\n  function getCompatibleData(next, data) {\n    // in mongoose5, 'data' field is undefined\n    if (!data) {\n      return next;\n    }\n    return data;\n  }\n\n  function encryptFields(obj, fields, secret) {\n    for (const field of fields) {\n      const encryptedFieldName = encryptedFieldNamePrefix + field;\n      const encryptedFieldData = encryptedFieldName + encryptedFieldDataSuffix;\n      const fieldValue = obj[field];\n\n      if (!obj[encryptedFieldName] && fieldValue) {\n        if (typeof fieldValue === \"string\") {\n          // handle strings separately to maintain searchability\n          const value = encryptionStrategy(fieldValue, secret, saltGenerator);\n          obj[field] = value;\n        } else {\n          const value = encryptionStrategy(JSON.stringify(fieldValue), secret, saltGenerator);\n          obj[field] = undefined;\n          obj[encryptedFieldData] = value;\n        }\n\n        obj[encryptedFieldName] = true;\n      }\n    }\n  }\n\n  function decryptFields(obj, fields, secret) {\n    for (const field of fields) {\n      const encryptedFieldName = encryptedFieldNamePrefix + field;\n      const encryptedFieldData = encryptedFieldName + encryptedFieldDataSuffix;\n\n      if (obj[encryptedFieldName]) {\n        if (obj[encryptedFieldData]) {\n          const encryptedValue = obj[encryptedFieldData];\n\n          obj[field] = JSON.parse(decrypt(encryptedValue, secret));\n          obj[encryptedFieldName] = false;\n          obj[encryptedFieldData] = \"\";\n        } else {\n          // If the field has been marked to not be retrieved, it'll be undefined\n          if (obj[field]) {\n            // handle strings separately to maintain searchability\n            const encryptedValue = obj[field];\n            obj[field] = decrypt(encryptedValue, secret);\n            obj[encryptedFieldName] = false;\n          }\n        }\n      }\n    }\n  }\n\n  function updateHook(_next) {\n    const next = getCompatitibleNextFunc(_next);\n    for (const field of fieldsToEncrypt) {\n      const encryptedFieldName = encryptedFieldNamePrefix + field;\n      this._update.$set = this._update.$set || {};\n      const plainTextValue = this._update.$set[field] || this._update[field];\n      const encryptedFieldValue = this._update.$set[encryptedFieldName] || this._update[encryptedFieldName];\n\n      if (!encryptedFieldValue && plainTextValue) {\n        const updateObj = {};\n        if (typeof plainTextValue === \"string\" || plainTextValue instanceof String) {\n          const encryptedData = encryptionStrategy(plainTextValue, secret, saltGenerator);\n\n          updateObj[field] = encryptedData;\n          updateObj[encryptedFieldName] = true;\n        } else {\n          const encryptedFieldData = encryptedFieldName + encryptedFieldDataSuffix;\n\n          updateObj[field] = undefined;\n          updateObj[encryptedFieldData] = encryptionStrategy(JSON.stringify(plainTextValue), secret, saltGenerator);\n          updateObj[encryptedFieldName] = true;\n        }\n        this.update({}, Object.keys(this._update.$set).length > 0 ? { $set: updateObj } : updateObj);\n      }\n    }\n\n    next();\n  }\n\n  //\n  // static methods\n  //\n\n  schema.methods.stripEncryptionFieldMarkers = function() {\n    for (const field of fieldsToEncrypt) {\n      const encryptedFieldName = encryptedFieldNamePrefix + field;\n      const encryptedFieldData = encryptedFieldName + encryptedFieldDataSuffix;\n\n      this.set(encryptedFieldName, undefined);\n      this.set(encryptedFieldData, undefined);\n    }\n  };\n\n  schema.methods.decryptFieldsSync = function() {\n    decryptFields(this, fieldsToEncrypt, secret);\n  };\n\n  schema.methods.encryptFieldsSync = function() {\n    encryptFields(this, fieldsToEncrypt, secret);\n  };\n\n  //\n  // hooks\n  //\n\n  schema.post(\"init\", function(_next, _data) {\n    const next = getCompatitibleNextFunc(_next);\n    const data = getCompatibleData(_next, _data);\n    try {\n      decryptFields(data, fieldsToEncrypt, secret);\n      next();\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  schema.pre(\"save\", function(_next) {\n    const next = getCompatitibleNextFunc(_next);\n\n    try {\n      encryptFields(this, fieldsToEncrypt, secret);\n      next();\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  schema.pre(\"findOneAndUpdate\", updateHook);\n\n  schema.pre(\"update\", updateHook);\n};\n\nmodule.exports.fieldEncryption = fieldEncryption;\nmodule.exports.encrypt = encrypt;\nmodule.exports.decrypt = decrypt;\nmodule.exports.encryptAes256Ctr = encryptAes256Ctr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UtZmllbGQtZW5jcnlwdGlvbi9saWIvbW9uZ29vc2UtZmllbGQtZW5jcnlwdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQWdELGtCQUFrQjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlY3VyZS1uZXh0LWZyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlLWZpZWxkLWVuY3J5cHRpb24vbGliL21vbmdvb3NlLWZpZWxkLWVuY3J5cHRpb24uanM/ZjM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxuY29uc3QgYWxnb3JpdGhtID0gXCJhZXMtMjU2LWNiY1wiO1xuY29uc3QgZGVwcmVjYXRlZEFsZ29yaXRobSA9IFwiYWVzLTI1Ni1jdHJcIjtcbmNvbnN0IGVuY3J5cHRlZEZpZWxkTmFtZVByZWZpeCA9IFwiX19lbmNfXCI7XG5jb25zdCBlbmNyeXB0ZWRGaWVsZERhdGFTdWZmaXggPSBcIl9kXCI7XG5cbmNvbnN0IGVuY3J5cHRBZXMyNTZDdHIgPSBmdW5jdGlvbih0ZXh0LCBzZWNyZXQpIHtcbiAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcihkZXByZWNhdGVkQWxnb3JpdGhtLCBzZWNyZXQpO1xuICBsZXQgY3J5cHRlZCA9IGNpcGhlci51cGRhdGUodGV4dCwgXCJ1dGY4XCIsIFwiaGV4XCIpO1xuICBjcnlwdGVkICs9IGNpcGhlci5maW5hbChcImhleFwiKTtcbiAgcmV0dXJuIGNyeXB0ZWQ7XG59O1xuXG5jb25zdCBkZWNyeXB0QWVzMjU2Q3RyID0gZnVuY3Rpb24oZW5jcnlwdGVkSGV4LCBzZWNyZXQpIHtcbiAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXIoZGVwcmVjYXRlZEFsZ29yaXRobSwgc2VjcmV0KTtcbiAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRIZXgsIFwiaGV4XCIsIFwidXRmOFwiKTtcbiAgZGVjICs9IGRlY2lwaGVyLmZpbmFsKFwidXRmOFwiKTtcbiAgcmV0dXJuIGRlYztcbn07XG5cbmNvbnN0IGVuY3J5cHQgPSBmdW5jdGlvbihjbGVhclRleHQsIHNlY3JldCwgc2FsdEdlbmVyYXRvcikge1xuICBjb25zdCBpdiA9IHNhbHRHZW5lcmF0b3JXcmFwcGVyKHNhbHRHZW5lcmF0b3Ioc2VjcmV0KSk7XG4gIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihhbGdvcml0aG0sIHNlY3JldCwgaXYpO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXIudXBkYXRlKGNsZWFyVGV4dCk7XG4gIGNvbnN0IGZpbmFsQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbZW5jcnlwdGVkLCBjaXBoZXIuZmluYWwoKV0pO1xuICBjb25zdCBlbmNyeXB0ZWRIZXggPSBpdi50b1N0cmluZyhcImhleFwiKSArIFwiOlwiICsgZmluYWxCdWZmZXIudG9TdHJpbmcoXCJoZXhcIik7XG4gIHJldHVybiBlbmNyeXB0ZWRIZXg7XG59O1xuXG5jb25zdCBzYWx0R2VuZXJhdG9yV3JhcHBlciA9IGl2ID0+IHtcbiAgaWYgKGl2IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgaWYgKGl2Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2FsdCBwcm92aWRlZCwgcGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBzYWx0IGlzIGEgQnVmZmVyIG9mIGxlbmd0aCAxNlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGl2O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpdiA9PT0gXCJzdHJpbmdcIiB8fCBpdiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGlmIChpdi5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNhbHQsIHBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgc2FsdCBpcyBhIHN0cmluZyBvZiBsZW5ndGggMTZcIik7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShpdik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNhbHQsIHBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgc2FsdCBpcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSBCdWZmZXIgb2YgbGVuZ3RoIDE2XCIpO1xufTtcblxuY29uc3QgZGVmYXVsdFNhbHRHZW5lcmF0b3IgPSBzZWNyZXQgPT4gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcblxuLyoqXG4gKiBEZWNyeXB0aW9uIGhhcyBhIGRlZmF1bHQgZmFsbGJhY2sgZm9yIHRoZSBkZXByZWNhdGVkIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSB7Kn0gZW5jcnlwdGVkSGV4XG4gKiBAcGFyYW0geyp9IHNlY3JldFxuICovXG5jb25zdCBkZWNyeXB0ID0gZnVuY3Rpb24oZW5jcnlwdGVkSGV4LCBzZWNyZXQpIHtcbiAgY29uc3QgZW5jcnlwdGVkQXJyYXkgPSBlbmNyeXB0ZWRIZXguc3BsaXQoXCI6XCIpO1xuXG4gIC8vIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGlmIChlbmNyeXB0ZWRBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGVjcnlwdEFlczI1NkN0cihlbmNyeXB0ZWRBcnJheVswXSwgc2VjcmV0KTtcbiAgfVxuXG4gIGNvbnN0IGl2ID0gbmV3IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZEFycmF5WzBdLCBcImhleFwiKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gbmV3IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZEFycmF5WzFdLCBcImhleFwiKTtcbiAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihhbGdvcml0aG0sIHNlY3JldCwgaXYpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgY29uc3QgY2xlYXJUZXh0ID0gQnVmZmVyLmNvbmNhdChbZGVjcnlwdGVkLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIGNsZWFyVGV4dDtcbn07XG5cbmNvbnN0IGZpZWxkRW5jcnlwdGlvbiA9IGZ1bmN0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyByZXF1aXJlZCBzZWNyZXRcIik7XG4gIH1cblxuICBjb25zdCB1c2VBZXMyNTZDdHIgPSBvcHRpb25zLnVzZUFlczI1NkN0ciB8fCBmYWxzZTtcbiAgY29uc3QgZmllbGRzVG9FbmNyeXB0ID0gb3B0aW9ucy5maWVsZHMgfHwgW107XG5cbiAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpO1xuICBoYXNoLnVwZGF0ZShvcHRpb25zLnNlY3JldCk7XG5cbiAgY29uc3Qgc2VjcmV0ID0gdXNlQWVzMjU2Q3RyID8gb3B0aW9ucy5zZWNyZXQgOiBoYXNoLmRpZ2VzdChcImhleFwiKS5zdWJzdHJpbmcoMCwgMzIpO1xuICBjb25zdCBlbmNyeXB0aW9uU3RyYXRlZ3kgPSB1c2VBZXMyNTZDdHIgPyBlbmNyeXB0QWVzMjU2Q3RyIDogZW5jcnlwdDtcbiAgY29uc3Qgc2FsdEdlbmVyYXRvciA9IG9wdGlvbnMuc2FsdEdlbmVyYXRvciA/IG9wdGlvbnMuc2FsdEdlbmVyYXRvciA6IGRlZmF1bHRTYWx0R2VuZXJhdG9yO1xuXG4gIC8vIGFkZCBtYXJrZXIgZmllbGRzIHRvIHNjaGVtYVxuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkc1RvRW5jcnlwdCkge1xuICAgIGNvbnN0IGVuY3J5cHRlZEZpZWxkTmFtZSA9IGVuY3J5cHRlZEZpZWxkTmFtZVByZWZpeCArIGZpZWxkO1xuICAgIGNvbnN0IGVuY3J5cHRlZEZpZWxkRGF0YSA9IGVuY3J5cHRlZEZpZWxkTmFtZSArIGVuY3J5cHRlZEZpZWxkRGF0YVN1ZmZpeDtcbiAgICBjb25zdCBzY2hlbWFGaWVsZCA9IHt9O1xuXG4gICAgc2NoZW1hRmllbGRbZW5jcnlwdGVkRmllbGROYW1lXSA9IHsgdHlwZTogQm9vbGVhbiB9O1xuICAgIHNjaGVtYUZpZWxkW2VuY3J5cHRlZEZpZWxkRGF0YV0gPSB7IHR5cGU6IFN0cmluZyB9O1xuICAgIHNjaGVtYS5hZGQoc2NoZW1hRmllbGQpO1xuICB9XG5cbiAgLy9cbiAgLy8gbG9jYWwgbWV0aG9kc1xuICAvL1xuXG4gIC8vIGZvciBtb25nb29zZSA0LzUgY29tcGF0aWJpbGl0eVxuICBjb25zdCBkZWZhdWx0TmV4dCA9IGZ1bmN0aW9uIGRlZmF1bHROZXh0KGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGF0aXRpYmxlTmV4dEZ1bmMobmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE5leHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGF0aWJsZURhdGEobmV4dCwgZGF0YSkge1xuICAgIC8vIGluIG1vbmdvb3NlNSwgJ2RhdGEnIGZpZWxkIGlzIHVuZGVmaW5lZFxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jcnlwdEZpZWxkcyhvYmosIGZpZWxkcywgc2VjcmV0KSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZEZpZWxkTmFtZSA9IGVuY3J5cHRlZEZpZWxkTmFtZVByZWZpeCArIGZpZWxkO1xuICAgICAgY29uc3QgZW5jcnlwdGVkRmllbGREYXRhID0gZW5jcnlwdGVkRmllbGROYW1lICsgZW5jcnlwdGVkRmllbGREYXRhU3VmZml4O1xuICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IG9ialtmaWVsZF07XG5cbiAgICAgIGlmICghb2JqW2VuY3J5cHRlZEZpZWxkTmFtZV0gJiYgZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBoYW5kbGUgc3RyaW5ncyBzZXBhcmF0ZWx5IHRvIG1haW50YWluIHNlYXJjaGFiaWxpdHlcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuY3J5cHRpb25TdHJhdGVneShmaWVsZFZhbHVlLCBzZWNyZXQsIHNhbHRHZW5lcmF0b3IpO1xuICAgICAgICAgIG9ialtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuY3J5cHRpb25TdHJhdGVneShKU09OLnN0cmluZ2lmeShmaWVsZFZhbHVlKSwgc2VjcmV0LCBzYWx0R2VuZXJhdG9yKTtcbiAgICAgICAgICBvYmpbZmllbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG9ialtlbmNyeXB0ZWRGaWVsZERhdGFdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbZW5jcnlwdGVkRmllbGROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjcnlwdEZpZWxkcyhvYmosIGZpZWxkcywgc2VjcmV0KSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZEZpZWxkTmFtZSA9IGVuY3J5cHRlZEZpZWxkTmFtZVByZWZpeCArIGZpZWxkO1xuICAgICAgY29uc3QgZW5jcnlwdGVkRmllbGREYXRhID0gZW5jcnlwdGVkRmllbGROYW1lICsgZW5jcnlwdGVkRmllbGREYXRhU3VmZml4O1xuXG4gICAgICBpZiAob2JqW2VuY3J5cHRlZEZpZWxkTmFtZV0pIHtcbiAgICAgICAgaWYgKG9ialtlbmNyeXB0ZWRGaWVsZERhdGFdKSB7XG4gICAgICAgICAgY29uc3QgZW5jcnlwdGVkVmFsdWUgPSBvYmpbZW5jcnlwdGVkRmllbGREYXRhXTtcblxuICAgICAgICAgIG9ialtmaWVsZF0gPSBKU09OLnBhcnNlKGRlY3J5cHQoZW5jcnlwdGVkVmFsdWUsIHNlY3JldCkpO1xuICAgICAgICAgIG9ialtlbmNyeXB0ZWRGaWVsZE5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgb2JqW2VuY3J5cHRlZEZpZWxkRGF0YV0gPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBmaWVsZCBoYXMgYmVlbiBtYXJrZWQgdG8gbm90IGJlIHJldHJpZXZlZCwgaXQnbGwgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgaWYgKG9ialtmaWVsZF0pIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBzdHJpbmdzIHNlcGFyYXRlbHkgdG8gbWFpbnRhaW4gc2VhcmNoYWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkVmFsdWUgPSBvYmpbZmllbGRdO1xuICAgICAgICAgICAgb2JqW2ZpZWxkXSA9IGRlY3J5cHQoZW5jcnlwdGVkVmFsdWUsIHNlY3JldCk7XG4gICAgICAgICAgICBvYmpbZW5jcnlwdGVkRmllbGROYW1lXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvb2soX25leHQpIHtcbiAgICBjb25zdCBuZXh0ID0gZ2V0Q29tcGF0aXRpYmxlTmV4dEZ1bmMoX25leHQpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzVG9FbmNyeXB0KSB7XG4gICAgICBjb25zdCBlbmNyeXB0ZWRGaWVsZE5hbWUgPSBlbmNyeXB0ZWRGaWVsZE5hbWVQcmVmaXggKyBmaWVsZDtcbiAgICAgIHRoaXMuX3VwZGF0ZS4kc2V0ID0gdGhpcy5fdXBkYXRlLiRzZXQgfHwge307XG4gICAgICBjb25zdCBwbGFpblRleHRWYWx1ZSA9IHRoaXMuX3VwZGF0ZS4kc2V0W2ZpZWxkXSB8fCB0aGlzLl91cGRhdGVbZmllbGRdO1xuICAgICAgY29uc3QgZW5jcnlwdGVkRmllbGRWYWx1ZSA9IHRoaXMuX3VwZGF0ZS4kc2V0W2VuY3J5cHRlZEZpZWxkTmFtZV0gfHwgdGhpcy5fdXBkYXRlW2VuY3J5cHRlZEZpZWxkTmFtZV07XG5cbiAgICAgIGlmICghZW5jcnlwdGVkRmllbGRWYWx1ZSAmJiBwbGFpblRleHRWYWx1ZSkge1xuICAgICAgICBjb25zdCB1cGRhdGVPYmogPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwbGFpblRleHRWYWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCBwbGFpblRleHRWYWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBlbmNyeXB0aW9uU3RyYXRlZ3kocGxhaW5UZXh0VmFsdWUsIHNlY3JldCwgc2FsdEdlbmVyYXRvcik7XG5cbiAgICAgICAgICB1cGRhdGVPYmpbZmllbGRdID0gZW5jcnlwdGVkRGF0YTtcbiAgICAgICAgICB1cGRhdGVPYmpbZW5jcnlwdGVkRmllbGROYW1lXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZW5jcnlwdGVkRmllbGREYXRhID0gZW5jcnlwdGVkRmllbGROYW1lICsgZW5jcnlwdGVkRmllbGREYXRhU3VmZml4O1xuXG4gICAgICAgICAgdXBkYXRlT2JqW2ZpZWxkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB1cGRhdGVPYmpbZW5jcnlwdGVkRmllbGREYXRhXSA9IGVuY3J5cHRpb25TdHJhdGVneShKU09OLnN0cmluZ2lmeShwbGFpblRleHRWYWx1ZSksIHNlY3JldCwgc2FsdEdlbmVyYXRvcik7XG4gICAgICAgICAgdXBkYXRlT2JqW2VuY3J5cHRlZEZpZWxkTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHt9LCBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUuJHNldCkubGVuZ3RoID4gMCA/IHsgJHNldDogdXBkYXRlT2JqIH0gOiB1cGRhdGVPYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIHN0YXRpYyBtZXRob2RzXG4gIC8vXG5cbiAgc2NoZW1hLm1ldGhvZHMuc3RyaXBFbmNyeXB0aW9uRmllbGRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNUb0VuY3J5cHQpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZEZpZWxkTmFtZSA9IGVuY3J5cHRlZEZpZWxkTmFtZVByZWZpeCArIGZpZWxkO1xuICAgICAgY29uc3QgZW5jcnlwdGVkRmllbGREYXRhID0gZW5jcnlwdGVkRmllbGROYW1lICsgZW5jcnlwdGVkRmllbGREYXRhU3VmZml4O1xuXG4gICAgICB0aGlzLnNldChlbmNyeXB0ZWRGaWVsZE5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLnNldChlbmNyeXB0ZWRGaWVsZERhdGEsIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9O1xuXG4gIHNjaGVtYS5tZXRob2RzLmRlY3J5cHRGaWVsZHNTeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgZGVjcnlwdEZpZWxkcyh0aGlzLCBmaWVsZHNUb0VuY3J5cHQsIHNlY3JldCk7XG4gIH07XG5cbiAgc2NoZW1hLm1ldGhvZHMuZW5jcnlwdEZpZWxkc1N5bmMgPSBmdW5jdGlvbigpIHtcbiAgICBlbmNyeXB0RmllbGRzKHRoaXMsIGZpZWxkc1RvRW5jcnlwdCwgc2VjcmV0KTtcbiAgfTtcblxuICAvL1xuICAvLyBob29rc1xuICAvL1xuXG4gIHNjaGVtYS5wb3N0KFwiaW5pdFwiLCBmdW5jdGlvbihfbmV4dCwgX2RhdGEpIHtcbiAgICBjb25zdCBuZXh0ID0gZ2V0Q29tcGF0aXRpYmxlTmV4dEZ1bmMoX25leHQpO1xuICAgIGNvbnN0IGRhdGEgPSBnZXRDb21wYXRpYmxlRGF0YShfbmV4dCwgX2RhdGEpO1xuICAgIHRyeSB7XG4gICAgICBkZWNyeXB0RmllbGRzKGRhdGEsIGZpZWxkc1RvRW5jcnlwdCwgc2VjcmV0KTtcbiAgICAgIG5leHQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG5leHQoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNjaGVtYS5wcmUoXCJzYXZlXCIsIGZ1bmN0aW9uKF9uZXh0KSB7XG4gICAgY29uc3QgbmV4dCA9IGdldENvbXBhdGl0aWJsZU5leHRGdW5jKF9uZXh0KTtcblxuICAgIHRyeSB7XG4gICAgICBlbmNyeXB0RmllbGRzKHRoaXMsIGZpZWxkc1RvRW5jcnlwdCwgc2VjcmV0KTtcbiAgICAgIG5leHQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG5leHQoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNjaGVtYS5wcmUoXCJmaW5kT25lQW5kVXBkYXRlXCIsIHVwZGF0ZUhvb2spO1xuXG4gIHNjaGVtYS5wcmUoXCJ1cGRhdGVcIiwgdXBkYXRlSG9vayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maWVsZEVuY3J5cHRpb24gPSBmaWVsZEVuY3J5cHRpb247XG5tb2R1bGUuZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcbm1vZHVsZS5leHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xubW9kdWxlLmV4cG9ydHMuZW5jcnlwdEFlczI1NkN0ciA9IGVuY3J5cHRBZXMyNTZDdHI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../backend/node_modules/mongoose-field-encryption/lib/mongoose-field-encryption.js\n");

/***/ })

};
;